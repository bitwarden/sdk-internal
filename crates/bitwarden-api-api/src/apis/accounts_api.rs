/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`accounts_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_delete_sso_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsDeleteSsoUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_account_revision_date`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetAccountRevisionDateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetKeysError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_organizations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetOrganizationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_sso_user_identifier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetSsoUserIdentifierError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_get_tax_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsGetTaxInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostAvatarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_cancel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostCancelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_delete_recover`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostDeleteRecoverError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_delete_recover_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostDeleteRecoverTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_email_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostEmailTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_kdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostKdfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostKeysError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_license`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostLicenseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_password_hint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostPasswordHintError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_payment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostPaymentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_premium`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostPremiumError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_reinstate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostReinstateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_request_otp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostRequestOtpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_security_stamp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostSecurityStampError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_set_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostSetPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_set_user_verify_devices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostSetUserVerifyDevicesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_storage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostStorageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_verify_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostVerifyEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_verify_email_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostVerifyEmailTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_post_verify_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPostVerifyPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_put_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPutAvatarError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_put_profile`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPutProfileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_put_tax_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPutTaxInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_put_update_tde_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPutUpdateTdePasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_put_update_temp_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPutUpdateTempPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_resend_new_device_otp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsResendNewDeviceOtpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_rotate_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsRotateApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_set_user_verify_devices`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSetUserVerifyDevicesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_otp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyOtpError {
    UnknownValue(serde_json::Value),
}

pub async fn accounts_api_key(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<AccountsApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/api-key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

///  This operation is defined on: [`https://github.com/bitwarden/server/blob/22420f595f2f50dd2fc0061743841285258aed22/src/Api/Auth/Controllers/AccountsController.cs#L435`]
pub async fn accounts_delete(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<AccountsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_delete_sso_user(
    configuration: &configuration::Configuration,
    organization_id: &str,
) -> Result<(), Error<AccountsDeleteSsoUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;

    let uri_str = format!(
        "{}/accounts/sso/{organizationId}",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsDeleteSsoUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_account_revision_date(
    configuration: &configuration::Configuration,
) -> Result<i64, Error<AccountsGetAccountRevisionDateError>> {
    let uri_str = format!("{}/accounts/revision-date", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i64`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i64`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetAccountRevisionDateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_keys(
    configuration: &configuration::Configuration,
) -> Result<models::KeysResponseModel, Error<AccountsGetKeysError>> {
    let uri_str = format!("{}/accounts/keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeysResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeysResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_organizations(
    configuration: &configuration::Configuration,
) -> Result<
    models::ProfileOrganizationResponseModelListResponseModel,
    Error<AccountsGetOrganizationsError>,
> {
    let uri_str = format!("{}/accounts/organizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetOrganizationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_profile(
    configuration: &configuration::Configuration,
) -> Result<models::ProfileResponseModel, Error<AccountsGetProfileError>> {
    let uri_str = format!("{}/accounts/profile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_sso_user_identifier(
    configuration: &configuration::Configuration,
) -> Result<String, Error<AccountsGetSsoUserIdentifierError>> {
    let uri_str = format!("{}/accounts/sso/user-identifier", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetSsoUserIdentifierError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_subscription(
    configuration: &configuration::Configuration,
) -> Result<models::SubscriptionResponseModel, Error<AccountsGetSubscriptionError>> {
    let uri_str = format!("{}/accounts/subscription", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubscriptionResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubscriptionResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_get_tax_info(
    configuration: &configuration::Configuration,
) -> Result<models::TaxInfoResponseModel, Error<AccountsGetTaxInfoError>> {
    let uri_str = format!("{}/accounts/tax", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaxInfoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaxInfoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsGetTaxInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_avatar(
    configuration: &configuration::Configuration,
    update_avatar_request_model: Option<models::UpdateAvatarRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsPostAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_avatar_request_model = update_avatar_request_model;

    let uri_str = format!("{}/accounts/avatar", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_avatar_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_cancel(
    configuration: &configuration::Configuration,
    subscription_cancellation_request_model: Option<models::SubscriptionCancellationRequestModel>,
) -> Result<(), Error<AccountsPostCancelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subscription_cancellation_request_model = subscription_cancellation_request_model;

    let uri_str = format!("{}/accounts/cancel", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_subscription_cancellation_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostCancelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_delete(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<AccountsPostDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/delete", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_delete_recover(
    configuration: &configuration::Configuration,
    delete_recover_request_model: Option<models::DeleteRecoverRequestModel>,
) -> Result<(), Error<AccountsPostDeleteRecoverError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_recover_request_model = delete_recover_request_model;

    let uri_str = format!("{}/accounts/delete-recover", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_delete_recover_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostDeleteRecoverError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_delete_recover_token(
    configuration: &configuration::Configuration,
    verify_delete_recover_request_model: Option<models::VerifyDeleteRecoverRequestModel>,
) -> Result<(), Error<AccountsPostDeleteRecoverTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_delete_recover_request_model = verify_delete_recover_request_model;

    let uri_str = format!("{}/accounts/delete-recover-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_delete_recover_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostDeleteRecoverTokenError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_email(
    configuration: &configuration::Configuration,
    email_request_model: Option<models::EmailRequestModel>,
) -> Result<(), Error<AccountsPostEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email_request_model = email_request_model;

    let uri_str = format!("{}/accounts/email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_email_token(
    configuration: &configuration::Configuration,
    email_token_request_model: Option<models::EmailTokenRequestModel>,
) -> Result<(), Error<AccountsPostEmailTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email_token_request_model = email_token_request_model;

    let uri_str = format!("{}/accounts/email-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_email_token_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostEmailTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_kdf(
    configuration: &configuration::Configuration,
    kdf_request_model: Option<models::KdfRequestModel>,
) -> Result<(), Error<AccountsPostKdfError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_kdf_request_model = kdf_request_model;

    let uri_str = format!("{}/accounts/kdf", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_kdf_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostKdfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_keys(
    configuration: &configuration::Configuration,
    keys_request_model: Option<models::KeysRequestModel>,
) -> Result<models::KeysResponseModel, Error<AccountsPostKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_keys_request_model = keys_request_model;

    let uri_str = format!("{}/accounts/keys", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_keys_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeysResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeysResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_license(
    configuration: &configuration::Configuration,
    license: std::path::PathBuf,
) -> Result<(), Error<AccountsPostLicenseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_license = license;

    let uri_str = format!("{}/accounts/license", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'license' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostLicenseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_password(
    configuration: &configuration::Configuration,
    password_request_model: Option<models::PasswordRequestModel>,
) -> Result<(), Error<AccountsPostPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_password_request_model = password_request_model;

    let uri_str = format!("{}/accounts/password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_password_hint(
    configuration: &configuration::Configuration,
    password_hint_request_model: Option<models::PasswordHintRequestModel>,
) -> Result<(), Error<AccountsPostPasswordHintError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_password_hint_request_model = password_hint_request_model;

    let uri_str = format!("{}/accounts/password-hint", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_password_hint_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostPasswordHintError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_payment(
    configuration: &configuration::Configuration,
    payment_request_model: Option<models::PaymentRequestModel>,
) -> Result<(), Error<AccountsPostPaymentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payment_request_model = payment_request_model;

    let uri_str = format!("{}/accounts/payment", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_payment_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostPaymentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_premium(
    configuration: &configuration::Configuration,
    payment_method_type: models::PaymentMethodType,
    payment_token: Option<&str>,
    additional_storage_gb: Option<i32>,
    country: Option<&str>,
    postal_code: Option<&str>,
    license: Option<std::path::PathBuf>,
) -> Result<models::PaymentResponseModel, Error<AccountsPostPremiumError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payment_method_type = payment_method_type;
    let p_payment_token = payment_token;
    let p_additional_storage_gb = additional_storage_gb;
    let p_country = country;
    let p_postal_code = postal_code;
    let p_license = license;

    let uri_str = format!("{}/accounts/premium", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("paymentMethodType", &p_payment_method_type.to_string())]);
    if let Some(ref param_value) = p_payment_token {
        req_builder = req_builder.query(&[("paymentToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_additional_storage_gb {
        req_builder = req_builder.query(&[("additionalStorageGb", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'license' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostPremiumError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_profile(
    configuration: &configuration::Configuration,
    update_profile_request_model: Option<models::UpdateProfileRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsPostProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_profile_request_model = update_profile_request_model;

    let uri_str = format!("{}/accounts/profile", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_profile_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_reinstate(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsPostReinstateError>> {
    let uri_str = format!("{}/accounts/reinstate-premium", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostReinstateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_request_otp(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsPostRequestOtpError>> {
    let uri_str = format!("{}/accounts/request-otp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostRequestOtpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_security_stamp(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<AccountsPostSecurityStampError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/security-stamp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostSecurityStampError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_set_password(
    configuration: &configuration::Configuration,
    set_password_request_model: Option<models::SetPasswordRequestModel>,
) -> Result<(), Error<AccountsPostSetPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_password_request_model = set_password_request_model;

    let uri_str = format!("{}/accounts/set-password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostSetPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_set_user_verify_devices(
    configuration: &configuration::Configuration,
    set_verify_devices_request_model: Option<models::SetVerifyDevicesRequestModel>,
) -> Result<(), Error<AccountsPostSetUserVerifyDevicesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_verify_devices_request_model = set_verify_devices_request_model;

    let uri_str = format!("{}/accounts/verify-devices", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_verify_devices_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostSetUserVerifyDevicesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_storage(
    configuration: &configuration::Configuration,
    storage_request_model: Option<models::StorageRequestModel>,
) -> Result<models::PaymentResponseModel, Error<AccountsPostStorageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_storage_request_model = storage_request_model;

    let uri_str = format!("{}/accounts/storage", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_storage_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostStorageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_verify_email(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsPostVerifyEmailError>> {
    let uri_str = format!("{}/accounts/verify-email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostVerifyEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_verify_email_token(
    configuration: &configuration::Configuration,
    verify_email_request_model: Option<models::VerifyEmailRequestModel>,
) -> Result<(), Error<AccountsPostVerifyEmailTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_email_request_model = verify_email_request_model;

    let uri_str = format!("{}/accounts/verify-email-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostVerifyEmailTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_post_verify_password(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::MasterPasswordPolicyResponseModel, Error<AccountsPostVerifyPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/verify-password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MasterPasswordPolicyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MasterPasswordPolicyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPostVerifyPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_put_avatar(
    configuration: &configuration::Configuration,
    update_avatar_request_model: Option<models::UpdateAvatarRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsPutAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_avatar_request_model = update_avatar_request_model;

    let uri_str = format!("{}/accounts/avatar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_avatar_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPutAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_put_profile(
    configuration: &configuration::Configuration,
    update_profile_request_model: Option<models::UpdateProfileRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsPutProfileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_profile_request_model = update_profile_request_model;

    let uri_str = format!("{}/accounts/profile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_profile_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPutProfileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_put_tax_info(
    configuration: &configuration::Configuration,
    tax_info_update_request_model: Option<models::TaxInfoUpdateRequestModel>,
) -> Result<(), Error<AccountsPutTaxInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tax_info_update_request_model = tax_info_update_request_model;

    let uri_str = format!("{}/accounts/tax", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tax_info_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPutTaxInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_put_update_tde_password(
    configuration: &configuration::Configuration,
    update_tde_offboarding_password_request_model: Option<
        models::UpdateTdeOffboardingPasswordRequestModel,
    >,
) -> Result<(), Error<AccountsPutUpdateTdePasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_tde_offboarding_password_request_model =
        update_tde_offboarding_password_request_model;

    let uri_str = format!(
        "{}/accounts/update-tde-offboarding-password",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_tde_offboarding_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPutUpdateTdePasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_put_update_temp_password(
    configuration: &configuration::Configuration,
    update_temp_password_request_model: Option<models::UpdateTempPasswordRequestModel>,
) -> Result<(), Error<AccountsPutUpdateTempPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_temp_password_request_model = update_temp_password_request_model;

    let uri_str = format!("{}/accounts/update-temp-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_temp_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPutUpdateTempPasswordError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_resend_new_device_otp(
    configuration: &configuration::Configuration,
    unauthenticated_secret_verification_request_model: Option<
        models::UnauthenticatedSecretVerificationRequestModel,
    >,
) -> Result<(), Error<AccountsResendNewDeviceOtpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_unauthenticated_secret_verification_request_model =
        unauthenticated_secret_verification_request_model;

    let uri_str = format!("{}/accounts/resend-new-device-otp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_unauthenticated_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsResendNewDeviceOtpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_rotate_api_key(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<AccountsRotateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/rotate-api-key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsRotateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_set_user_verify_devices(
    configuration: &configuration::Configuration,
    set_verify_devices_request_model: Option<models::SetVerifyDevicesRequestModel>,
) -> Result<(), Error<AccountsSetUserVerifyDevicesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_verify_devices_request_model = set_verify_devices_request_model;

    let uri_str = format!("{}/accounts/verify-devices", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_verify_devices_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSetUserVerifyDevicesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_otp(
    configuration: &configuration::Configuration,
    verify_otp_request_model: Option<models::VerifyOtpRequestModel>,
) -> Result<(), Error<AccountsVerifyOtpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_otp_request_model = verify_otp_request_model;

    let uri_str = format!("{}/accounts/verify-otp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_otp_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyOtpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
