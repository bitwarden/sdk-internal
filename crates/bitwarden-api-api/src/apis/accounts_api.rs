/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`accounts_api_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsApiKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_avatar_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAvatarPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_avatar_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsAvatarPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsCancelPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_convert_to_key_connector_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsConvertToKeyConnectorPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsDeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_delete_recover_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsDeleteRecoverPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_delete_recover_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsDeleteRecoverTokenPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_email_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsEmailPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_email_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsEmailTokenPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_kdf_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsKdfPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsKeysGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsKeysPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_license_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsLicensePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_organizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsOrganizationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_password_hint_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPasswordHintPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPasswordPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_payment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPaymentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_premium_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsPremiumPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfilePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_profile_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsProfilePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_reinstate_premium_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsReinstatePremiumPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_request_otp_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsRequestOtpPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_resend_new_device_otp_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsResendNewDeviceOtpPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_revision_date_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsRevisionDateGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_rotate_api_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsRotateApiKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_security_stamp_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSecurityStampPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_set_key_connector_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSetKeyConnectorKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_set_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSetPasswordPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_sso_organization_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSsoOrganizationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_sso_user_identifier_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSsoUserIdentifierGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_storage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsStoragePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_subscription_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsSubscriptionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_tax_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsTaxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_tax_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsTaxPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_update_tde_offboarding_password_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsUpdateTdeOffboardingPasswordPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_update_temp_password_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsUpdateTempPasswordPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_devices_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyDevicesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_devices_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyDevicesPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_email_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyEmailPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_email_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyEmailTokenPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_otp_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyOtpPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accounts_verify_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AccountsVerifyPasswordPostError {
    UnknownValue(serde_json::Value),
}

pub async fn accounts_api_key_post(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<AccountsApiKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/api-key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsApiKeyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_avatar_post(
    configuration: &configuration::Configuration,
    update_avatar_request_model: Option<models::UpdateAvatarRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsAvatarPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_avatar_request_model = update_avatar_request_model;

    let uri_str = format!("{}/accounts/avatar", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_avatar_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAvatarPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_avatar_put(
    configuration: &configuration::Configuration,
    update_avatar_request_model: Option<models::UpdateAvatarRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsAvatarPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_avatar_request_model = update_avatar_request_model;

    let uri_str = format!("{}/accounts/avatar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_avatar_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsAvatarPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_cancel_post(
    configuration: &configuration::Configuration,
    subscription_cancellation_request_model: Option<models::SubscriptionCancellationRequestModel>,
) -> Result<(), Error<AccountsCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_subscription_cancellation_request_model = subscription_cancellation_request_model;

    let uri_str = format!("{}/accounts/cancel", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_subscription_cancellation_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_convert_to_key_connector_post(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsConvertToKeyConnectorPostError>> {
    let uri_str = format!(
        "{}/accounts/convert-to-key-connector",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsConvertToKeyConnectorPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_delete(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<AccountsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_delete_post(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<AccountsDeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/delete", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsDeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_delete_recover_post(
    configuration: &configuration::Configuration,
    delete_recover_request_model: Option<models::DeleteRecoverRequestModel>,
) -> Result<(), Error<AccountsDeleteRecoverPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_delete_recover_request_model = delete_recover_request_model;

    let uri_str = format!("{}/accounts/delete-recover", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_delete_recover_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsDeleteRecoverPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_delete_recover_token_post(
    configuration: &configuration::Configuration,
    verify_delete_recover_request_model: Option<models::VerifyDeleteRecoverRequestModel>,
) -> Result<(), Error<AccountsDeleteRecoverTokenPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_delete_recover_request_model = verify_delete_recover_request_model;

    let uri_str = format!("{}/accounts/delete-recover-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_delete_recover_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsDeleteRecoverTokenPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_email_post(
    configuration: &configuration::Configuration,
    email_request_model: Option<models::EmailRequestModel>,
) -> Result<(), Error<AccountsEmailPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email_request_model = email_request_model;

    let uri_str = format!("{}/accounts/email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsEmailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_email_token_post(
    configuration: &configuration::Configuration,
    email_token_request_model: Option<models::EmailTokenRequestModel>,
) -> Result<(), Error<AccountsEmailTokenPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_email_token_request_model = email_token_request_model;

    let uri_str = format!("{}/accounts/email-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_email_token_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsEmailTokenPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_kdf_post(
    configuration: &configuration::Configuration,
    kdf_request_model: Option<models::KdfRequestModel>,
) -> Result<(), Error<AccountsKdfPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_kdf_request_model = kdf_request_model;

    let uri_str = format!("{}/accounts/kdf", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_kdf_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsKdfPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_key_post(
    configuration: &configuration::Configuration,
    update_key_request_model: Option<models::UpdateKeyRequestModel>,
) -> Result<(), Error<AccountsKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_key_request_model = update_key_request_model;

    let uri_str = format!("{}/accounts/key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_key_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsKeyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_keys_get(
    configuration: &configuration::Configuration,
) -> Result<models::KeysResponseModel, Error<AccountsKeysGetError>> {
    let uri_str = format!("{}/accounts/keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeysResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeysResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsKeysGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_keys_post(
    configuration: &configuration::Configuration,
    keys_request_model: Option<models::KeysRequestModel>,
) -> Result<models::KeysResponseModel, Error<AccountsKeysPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_keys_request_model = keys_request_model;

    let uri_str = format!("{}/accounts/keys", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_keys_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KeysResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KeysResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsKeysPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_license_post(
    configuration: &configuration::Configuration,
    license: std::path::PathBuf,
) -> Result<(), Error<AccountsLicensePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_license = license;

    let uri_str = format!("{}/accounts/license", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'license' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsLicensePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_organizations_get(
    configuration: &configuration::Configuration,
) -> Result<
    models::ProfileOrganizationResponseModelListResponseModel,
    Error<AccountsOrganizationsGetError>,
> {
    let uri_str = format!("{}/accounts/organizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsOrganizationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_password_hint_post(
    configuration: &configuration::Configuration,
    password_hint_request_model: Option<models::PasswordHintRequestModel>,
) -> Result<(), Error<AccountsPasswordHintPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_password_hint_request_model = password_hint_request_model;

    let uri_str = format!("{}/accounts/password-hint", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_password_hint_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPasswordHintPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_password_post(
    configuration: &configuration::Configuration,
    password_request_model: Option<models::PasswordRequestModel>,
) -> Result<(), Error<AccountsPasswordPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_password_request_model = password_request_model;

    let uri_str = format!("{}/accounts/password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_payment_post(
    configuration: &configuration::Configuration,
    payment_request_model: Option<models::PaymentRequestModel>,
) -> Result<(), Error<AccountsPaymentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payment_request_model = payment_request_model;

    let uri_str = format!("{}/accounts/payment", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_payment_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPaymentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_premium_post(
    configuration: &configuration::Configuration,
    payment_method_type: models::PaymentMethodType,
    payment_token: Option<&str>,
    additional_storage_gb: Option<i32>,
    country: Option<&str>,
    postal_code: Option<&str>,
    license: Option<std::path::PathBuf>,
) -> Result<models::PaymentResponseModel, Error<AccountsPremiumPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_payment_method_type = payment_method_type;
    let p_payment_token = payment_token;
    let p_additional_storage_gb = additional_storage_gb;
    let p_country = country;
    let p_postal_code = postal_code;
    let p_license = license;

    let uri_str = format!("{}/accounts/premium", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("paymentMethodType", &p_payment_method_type.to_string())]);
    if let Some(ref param_value) = p_payment_token {
        req_builder = req_builder.query(&[("paymentToken", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_additional_storage_gb {
        req_builder = req_builder.query(&[("additionalStorageGb", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_country {
        req_builder = req_builder.query(&[("country", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_postal_code {
        req_builder = req_builder.query(&[("postalCode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'license' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsPremiumPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_profile_get(
    configuration: &configuration::Configuration,
) -> Result<models::ProfileResponseModel, Error<AccountsProfileGetError>> {
    let uri_str = format!("{}/accounts/profile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_profile_post(
    configuration: &configuration::Configuration,
    update_profile_request_model: Option<models::UpdateProfileRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsProfilePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_profile_request_model = update_profile_request_model;

    let uri_str = format!("{}/accounts/profile", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_profile_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfilePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_profile_put(
    configuration: &configuration::Configuration,
    update_profile_request_model: Option<models::UpdateProfileRequestModel>,
) -> Result<models::ProfileResponseModel, Error<AccountsProfilePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_profile_request_model = update_profile_request_model;

    let uri_str = format!("{}/accounts/profile", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_profile_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsProfilePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_reinstate_premium_post(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsReinstatePremiumPostError>> {
    let uri_str = format!("{}/accounts/reinstate-premium", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsReinstatePremiumPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_request_otp_post(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsRequestOtpPostError>> {
    let uri_str = format!("{}/accounts/request-otp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsRequestOtpPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_resend_new_device_otp_post(
    configuration: &configuration::Configuration,
    unauthenticated_secret_verification_request_model: Option<
        models::UnauthenticatedSecretVerificationRequestModel,
    >,
) -> Result<(), Error<AccountsResendNewDeviceOtpPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_unauthenticated_secret_verification_request_model =
        unauthenticated_secret_verification_request_model;

    let uri_str = format!("{}/accounts/resend-new-device-otp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_unauthenticated_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsResendNewDeviceOtpPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_revision_date_get(
    configuration: &configuration::Configuration,
) -> Result<i64, Error<AccountsRevisionDateGetError>> {
    let uri_str = format!("{}/accounts/revision-date", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `i64`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `i64`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsRevisionDateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_rotate_api_key_post(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<AccountsRotateApiKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/rotate-api-key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsRotateApiKeyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_security_stamp_post(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<AccountsSecurityStampPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/security-stamp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSecurityStampPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_set_key_connector_key_post(
    configuration: &configuration::Configuration,
    set_key_connector_key_request_model: Option<models::SetKeyConnectorKeyRequestModel>,
) -> Result<(), Error<AccountsSetKeyConnectorKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_key_connector_key_request_model = set_key_connector_key_request_model;

    let uri_str = format!("{}/accounts/set-key-connector-key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_key_connector_key_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSetKeyConnectorKeyPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_set_password_post(
    configuration: &configuration::Configuration,
    set_password_request_model: Option<models::SetPasswordRequestModel>,
) -> Result<(), Error<AccountsSetPasswordPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_password_request_model = set_password_request_model;

    let uri_str = format!("{}/accounts/set-password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSetPasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_sso_organization_id_delete(
    configuration: &configuration::Configuration,
    organization_id: &str,
) -> Result<(), Error<AccountsSsoOrganizationIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;

    let uri_str = format!(
        "{}/accounts/sso/{organizationId}",
        configuration.base_path,
        organizationId = crate::apis::urlencode(p_organization_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSsoOrganizationIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_sso_user_identifier_get(
    configuration: &configuration::Configuration,
) -> Result<String, Error<AccountsSsoUserIdentifierGetError>> {
    let uri_str = format!("{}/accounts/sso/user-identifier", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSsoUserIdentifierGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_storage_post(
    configuration: &configuration::Configuration,
    storage_request_model: Option<models::StorageRequestModel>,
) -> Result<models::PaymentResponseModel, Error<AccountsStoragePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_storage_request_model = storage_request_model;

    let uri_str = format!("{}/accounts/storage", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_storage_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsStoragePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_subscription_get(
    configuration: &configuration::Configuration,
) -> Result<models::SubscriptionResponseModel, Error<AccountsSubscriptionGetError>> {
    let uri_str = format!("{}/accounts/subscription", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubscriptionResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubscriptionResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsSubscriptionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_tax_get(
    configuration: &configuration::Configuration,
) -> Result<models::TaxInfoResponseModel, Error<AccountsTaxGetError>> {
    let uri_str = format!("{}/accounts/tax", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaxInfoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaxInfoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsTaxGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_tax_put(
    configuration: &configuration::Configuration,
    tax_info_update_request_model: Option<models::TaxInfoUpdateRequestModel>,
) -> Result<(), Error<AccountsTaxPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tax_info_update_request_model = tax_info_update_request_model;

    let uri_str = format!("{}/accounts/tax", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_tax_info_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsTaxPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_update_tde_offboarding_password_put(
    configuration: &configuration::Configuration,
    update_tde_offboarding_password_request_model: Option<
        models::UpdateTdeOffboardingPasswordRequestModel,
    >,
) -> Result<(), Error<AccountsUpdateTdeOffboardingPasswordPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_tde_offboarding_password_request_model =
        update_tde_offboarding_password_request_model;

    let uri_str = format!(
        "{}/accounts/update-tde-offboarding-password",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_tde_offboarding_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsUpdateTdeOffboardingPasswordPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_update_temp_password_put(
    configuration: &configuration::Configuration,
    update_temp_password_request_model: Option<models::UpdateTempPasswordRequestModel>,
) -> Result<(), Error<AccountsUpdateTempPasswordPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_temp_password_request_model = update_temp_password_request_model;

    let uri_str = format!("{}/accounts/update-temp-password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_temp_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsUpdateTempPasswordPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_devices_post(
    configuration: &configuration::Configuration,
    set_verify_devices_request_model: Option<models::SetVerifyDevicesRequestModel>,
) -> Result<(), Error<AccountsVerifyDevicesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_verify_devices_request_model = set_verify_devices_request_model;

    let uri_str = format!("{}/accounts/verify-devices", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_verify_devices_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyDevicesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_devices_put(
    configuration: &configuration::Configuration,
    set_verify_devices_request_model: Option<models::SetVerifyDevicesRequestModel>,
) -> Result<(), Error<AccountsVerifyDevicesPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_set_verify_devices_request_model = set_verify_devices_request_model;

    let uri_str = format!("{}/accounts/verify-devices", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_set_verify_devices_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyDevicesPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_email_post(
    configuration: &configuration::Configuration,
) -> Result<(), Error<AccountsVerifyEmailPostError>> {
    let uri_str = format!("{}/accounts/verify-email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyEmailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_email_token_post(
    configuration: &configuration::Configuration,
    verify_email_request_model: Option<models::VerifyEmailRequestModel>,
) -> Result<(), Error<AccountsVerifyEmailTokenPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_email_request_model = verify_email_request_model;

    let uri_str = format!("{}/accounts/verify-email-token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyEmailTokenPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_otp_post(
    configuration: &configuration::Configuration,
    verify_otp_request_model: Option<models::VerifyOtpRequestModel>,
) -> Result<(), Error<AccountsVerifyOtpPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_verify_otp_request_model = verify_otp_request_model;

    let uri_str = format!("{}/accounts/verify-otp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_verify_otp_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyOtpPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn accounts_verify_password_post(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::MasterPasswordPolicyResponseModel, Error<AccountsVerifyPasswordPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/accounts/verify-password", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MasterPasswordPolicyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MasterPasswordPolicyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AccountsVerifyPasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
