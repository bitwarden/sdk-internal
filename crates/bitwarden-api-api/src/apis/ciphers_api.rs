/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`ciphers_admin_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersAdminDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_attachment_validate_azure_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersAttachmentValidateAzurePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_bulk_collections_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersBulkCollectionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_create_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersCreatePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_delete_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersDeleteAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_delete_admin_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersDeleteAdminPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersDeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_delete_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersDeletePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_admin_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAdminDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_admin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAdminGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_admin_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAdminPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_admin_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdAdminDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_admin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdAdminGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_delete_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdDeleteAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdDeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_renew_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdRenewGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_attachment_id_share_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentAttachmentIdSharePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_attachment_v2_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdAttachmentV2PostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_collections_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdCollectionsAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_collections_admin_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdCollectionsAdminPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_collections_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdCollectionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_collections_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdCollectionsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_collections_v2_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdCollectionsV2PostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_collections_v2_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdCollectionsV2PutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_delete_admin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdDeleteAdminPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_delete_admin_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdDeleteAdminPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdDeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_delete_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdDeletePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_full_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdFullDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_partial_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdPartialPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_partial_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdPartialPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_restore_admin_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdRestoreAdminPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_restore_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdRestorePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_share_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdSharePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_id_share_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersIdSharePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_move_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersMovePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_move_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersMovePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_organization_details_assigned_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersOrganizationDetailsAssignedGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_organization_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersOrganizationDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_purge_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersPurgePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_restore_admin_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersRestoreAdminPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_restore_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersRestorePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_share_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersSharePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ciphers_share_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CiphersSharePutError {
    UnknownValue(serde_json::Value),
}

pub async fn ciphers_admin_delete(
    configuration: &configuration::Configuration,
    cipher_bulk_delete_request_model: Option<models::CipherBulkDeleteRequestModel>,
) -> Result<(), Error<CiphersAdminDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_delete_request_model = cipher_bulk_delete_request_model;

    let uri_str = format!("{}/ciphers/admin", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersAdminDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_admin_post(
    configuration: &configuration::Configuration,
    cipher_create_request_model: Option<models::CipherCreateRequestModel>,
) -> Result<models::CipherMiniResponseModel, Error<CiphersAdminPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_create_request_model = cipher_create_request_model;

    let uri_str = format!("{}/ciphers/admin", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_create_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersAdminPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_attachment_validate_azure_post(
    configuration: &configuration::Configuration,
) -> Result<(), Error<CiphersAttachmentValidateAzurePostError>> {
    let uri_str = format!(
        "{}/ciphers/attachment/validate/azure",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersAttachmentValidateAzurePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_bulk_collections_post(
    configuration: &configuration::Configuration,
    cipher_bulk_update_collections_request_model: Option<
        models::CipherBulkUpdateCollectionsRequestModel,
    >,
) -> Result<(), Error<CiphersBulkCollectionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_update_collections_request_model =
        cipher_bulk_update_collections_request_model;

    let uri_str = format!("{}/ciphers/bulk-collections", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_update_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersBulkCollectionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_create_post(
    configuration: &configuration::Configuration,
    cipher_create_request_model: Option<models::CipherCreateRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersCreatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_create_request_model = cipher_create_request_model;

    let uri_str = format!("{}/ciphers/create", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_create_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersCreatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_delete(
    configuration: &configuration::Configuration,
    cipher_bulk_delete_request_model: Option<models::CipherBulkDeleteRequestModel>,
) -> Result<(), Error<CiphersDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_delete_request_model = cipher_bulk_delete_request_model;

    let uri_str = format!("{}/ciphers", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_delete_admin_post(
    configuration: &configuration::Configuration,
    cipher_bulk_delete_request_model: Option<models::CipherBulkDeleteRequestModel>,
) -> Result<(), Error<CiphersDeleteAdminPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_delete_request_model = cipher_bulk_delete_request_model;

    let uri_str = format!("{}/ciphers/delete-admin", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersDeleteAdminPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_delete_admin_put(
    configuration: &configuration::Configuration,
    cipher_bulk_delete_request_model: Option<models::CipherBulkDeleteRequestModel>,
) -> Result<(), Error<CiphersDeleteAdminPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_delete_request_model = cipher_bulk_delete_request_model;

    let uri_str = format!("{}/ciphers/delete-admin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersDeleteAdminPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_delete_post(
    configuration: &configuration::Configuration,
    cipher_bulk_delete_request_model: Option<models::CipherBulkDeleteRequestModel>,
) -> Result<(), Error<CiphersDeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_delete_request_model = cipher_bulk_delete_request_model;

    let uri_str = format!("{}/ciphers/delete", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersDeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_delete_put(
    configuration: &configuration::Configuration,
    cipher_bulk_delete_request_model: Option<models::CipherBulkDeleteRequestModel>,
) -> Result<(), Error<CiphersDeletePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_delete_request_model = cipher_bulk_delete_request_model;

    let uri_str = format!("{}/ciphers/delete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersDeletePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_get(
    configuration: &configuration::Configuration,
) -> Result<models::CipherDetailsResponseModelListResponseModel, Error<CiphersGetError>> {
    let uri_str = format!("{}/ciphers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherDetailsResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherDetailsResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_admin_delete(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<CiphersIdAdminDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAdminDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_admin_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CipherMiniResponseModel, Error<CiphersIdAdminGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAdminGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_admin_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_request_model: Option<models::CipherRequestModel>,
) -> Result<models::CipherMiniResponseModel, Error<CiphersIdAdminPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_request_model = cipher_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAdminPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_admin_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_request_model: Option<models::CipherRequestModel>,
) -> Result<models::CipherMiniResponseModel, Error<CiphersIdAdminPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_request_model = cipher_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAdminPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_admin_post(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::CipherMiniResponseModel, Error<CiphersIdAttachmentAdminPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAdminPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_admin_delete(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<
    models::DeleteAttachmentResponseData,
    Error<CiphersIdAttachmentAttachmentIdAdminDeleteError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}/admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteAttachmentResponseData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteAttachmentResponseData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdAdminDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_admin_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<models::AttachmentResponseModel, Error<CiphersIdAttachmentAttachmentIdAdminGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}/admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttachmentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttachmentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdAdminGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_delete(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<models::DeleteAttachmentResponseData, Error<CiphersIdAttachmentAttachmentIdDeleteError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteAttachmentResponseData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteAttachmentResponseData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_delete_admin_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<
    models::DeleteAttachmentResponseData,
    Error<CiphersIdAttachmentAttachmentIdDeleteAdminPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}/delete-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteAttachmentResponseData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteAttachmentResponseData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdDeleteAdminPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_delete_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<
    models::DeleteAttachmentResponseData,
    Error<CiphersIdAttachmentAttachmentIdDeletePostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}/delete",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteAttachmentResponseData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteAttachmentResponseData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdDeletePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<models::AttachmentResponseModel, Error<CiphersIdAttachmentAttachmentIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttachmentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttachmentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<(), Error<CiphersIdAttachmentAttachmentIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_renew_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_id: &str,
) -> Result<
    models::AttachmentUploadDataResponseModel,
    Error<CiphersIdAttachmentAttachmentIdRenewGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}/renew",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttachmentUploadDataResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttachmentUploadDataResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdRenewGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_attachment_id_share_post(
    configuration: &configuration::Configuration,
    id: &str,
    attachment_id: &str,
    organization_id: Option<uuid::Uuid>,
) -> Result<(), Error<CiphersIdAttachmentAttachmentIdSharePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_id = attachment_id;
    let p_organization_id = organization_id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/{attachmentId}/share",
        configuration.base_path,
        id = crate::apis::urlencode(p_id),
        attachmentId = crate::apis::urlencode(p_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_organization_id {
        req_builder = req_builder.query(&[("organizationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentAttachmentIdSharePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::CipherResponseModel, Error<CiphersIdAttachmentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_attachment_v2_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    attachment_request_model: Option<models::AttachmentRequestModel>,
) -> Result<models::AttachmentUploadDataResponseModel, Error<CiphersIdAttachmentV2PostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_attachment_request_model = attachment_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/attachment/v2",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_attachment_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttachmentUploadDataResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttachmentUploadDataResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdAttachmentV2PostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_collections_admin_post(
    configuration: &configuration::Configuration,
    id: &str,
    cipher_collections_request_model: Option<models::CipherCollectionsRequestModel>,
) -> Result<models::CipherMiniDetailsResponseModel, Error<CiphersIdCollectionsAdminPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_collections_request_model = cipher_collections_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/collections-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdCollectionsAdminPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_collections_admin_put(
    configuration: &configuration::Configuration,
    id: &str,
    cipher_collections_request_model: Option<models::CipherCollectionsRequestModel>,
) -> Result<models::CipherMiniDetailsResponseModel, Error<CiphersIdCollectionsAdminPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_collections_request_model = cipher_collections_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/collections-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdCollectionsAdminPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_collections_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_collections_request_model: Option<models::CipherCollectionsRequestModel>,
) -> Result<models::CipherDetailsResponseModel, Error<CiphersIdCollectionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_collections_request_model = cipher_collections_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/collections",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdCollectionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_collections_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_collections_request_model: Option<models::CipherCollectionsRequestModel>,
) -> Result<models::CipherDetailsResponseModel, Error<CiphersIdCollectionsPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_collections_request_model = cipher_collections_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/collections",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdCollectionsPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_collections_v2_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_collections_request_model: Option<models::CipherCollectionsRequestModel>,
) -> Result<models::OptionalCipherDetailsResponseModel, Error<CiphersIdCollectionsV2PostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_collections_request_model = cipher_collections_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/collections_v2",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OptionalCipherDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OptionalCipherDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdCollectionsV2PostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_collections_v2_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_collections_request_model: Option<models::CipherCollectionsRequestModel>,
) -> Result<models::OptionalCipherDetailsResponseModel, Error<CiphersIdCollectionsV2PutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_collections_request_model = cipher_collections_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/collections_v2",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_collections_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OptionalCipherDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OptionalCipherDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdCollectionsV2PutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_delete(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<CiphersIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_delete_admin_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<CiphersIdDeleteAdminPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/delete-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdDeleteAdminPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_delete_admin_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<CiphersIdDeleteAdminPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/delete-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdDeleteAdminPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_delete_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<CiphersIdDeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/delete",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdDeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_delete_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<CiphersIdDeletePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/delete",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdDeletePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_details_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::CipherDetailsResponseModel, Error<CiphersIdDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/details",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_full_details_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::CipherDetailsResponseModel, Error<CiphersIdFullDetailsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/full-details",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdFullDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::CipherResponseModel, Error<CiphersIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_partial_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_partial_request_model: Option<models::CipherPartialRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersIdPartialPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_partial_request_model = cipher_partial_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/partial",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_partial_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdPartialPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_partial_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_partial_request_model: Option<models::CipherPartialRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersIdPartialPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_partial_request_model = cipher_partial_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/partial",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_partial_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdPartialPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_request_model: Option<models::CipherRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_request_model = cipher_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_request_model: Option<models::CipherRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_request_model = cipher_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_restore_admin_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::CipherMiniResponseModel, Error<CiphersIdRestoreAdminPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/restore-admin",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdRestoreAdminPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_restore_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::CipherResponseModel, Error<CiphersIdRestorePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/ciphers/{id}/restore",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdRestorePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_share_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_share_request_model: Option<models::CipherShareRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersIdSharePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_share_request_model = cipher_share_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/share",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_share_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdSharePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_id_share_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    cipher_share_request_model: Option<models::CipherShareRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersIdSharePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_cipher_share_request_model = cipher_share_request_model;

    let uri_str = format!(
        "{}/ciphers/{id}/share",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_share_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersIdSharePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_move_post(
    configuration: &configuration::Configuration,
    cipher_bulk_move_request_model: Option<models::CipherBulkMoveRequestModel>,
) -> Result<(), Error<CiphersMovePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_move_request_model = cipher_bulk_move_request_model;

    let uri_str = format!("{}/ciphers/move", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_move_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersMovePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_move_put(
    configuration: &configuration::Configuration,
    cipher_bulk_move_request_model: Option<models::CipherBulkMoveRequestModel>,
) -> Result<(), Error<CiphersMovePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_move_request_model = cipher_bulk_move_request_model;

    let uri_str = format!("{}/ciphers/move", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_move_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersMovePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_organization_details_assigned_get(
    configuration: &configuration::Configuration,
    organization_id: Option<uuid::Uuid>,
) -> Result<
    models::CipherDetailsResponseModelListResponseModel,
    Error<CiphersOrganizationDetailsAssignedGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;

    let uri_str = format!(
        "{}/ciphers/organization-details/assigned",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_organization_id {
        req_builder = req_builder.query(&[("organizationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherDetailsResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherDetailsResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersOrganizationDetailsAssignedGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_organization_details_get(
    configuration: &configuration::Configuration,
    organization_id: Option<uuid::Uuid>,
) -> Result<
    models::CipherMiniDetailsResponseModelListResponseModel,
    Error<CiphersOrganizationDetailsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;

    let uri_str = format!("{}/ciphers/organization-details", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_organization_id {
        req_builder = req_builder.query(&[("organizationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniDetailsResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniDetailsResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersOrganizationDetailsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_post(
    configuration: &configuration::Configuration,
    cipher_request_model: Option<models::CipherRequestModel>,
) -> Result<models::CipherResponseModel, Error<CiphersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_request_model = cipher_request_model;

    let uri_str = format!("{}/ciphers", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_purge_post(
    configuration: &configuration::Configuration,
    organization_id: Option<&str>,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<CiphersPurgePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_id = organization_id;
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/ciphers/purge", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_organization_id {
        req_builder = req_builder.query(&[("organizationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersPurgePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_restore_admin_put(
    configuration: &configuration::Configuration,
    cipher_bulk_restore_request_model: Option<models::CipherBulkRestoreRequestModel>,
) -> Result<models::CipherMiniResponseModelListResponseModel, Error<CiphersRestoreAdminPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_restore_request_model = cipher_bulk_restore_request_model;

    let uri_str = format!("{}/ciphers/restore-admin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_restore_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersRestoreAdminPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_restore_put(
    configuration: &configuration::Configuration,
    cipher_bulk_restore_request_model: Option<models::CipherBulkRestoreRequestModel>,
) -> Result<models::CipherMiniResponseModelListResponseModel, Error<CiphersRestorePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_restore_request_model = cipher_bulk_restore_request_model;

    let uri_str = format!("{}/ciphers/restore", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_restore_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersRestorePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_share_post(
    configuration: &configuration::Configuration,
    cipher_bulk_share_request_model: Option<models::CipherBulkShareRequestModel>,
) -> Result<models::CipherMiniResponseModelListResponseModel, Error<CiphersSharePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_share_request_model = cipher_bulk_share_request_model;

    let uri_str = format!("{}/ciphers/share", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_share_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersSharePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn ciphers_share_put(
    configuration: &configuration::Configuration,
    cipher_bulk_share_request_model: Option<models::CipherBulkShareRequestModel>,
) -> Result<models::CipherMiniResponseModelListResponseModel, Error<CiphersSharePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cipher_bulk_share_request_model = cipher_bulk_share_request_model;

    let uri_str = format!("{}/ciphers/share", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_cipher_bulk_share_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CipherMiniResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CiphersSharePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
