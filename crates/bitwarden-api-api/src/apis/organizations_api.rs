/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`organizations_create_without_payment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsCreateWithoutPaymentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_api_key_information_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdApiKeyInformationTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_api_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdApiKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdCancelPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_collection_management_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdCollectionManagementPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdDeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_delete_recover_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdDeleteRecoverTokenPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_keys_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdKeysGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdKeysPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_leave_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdLeavePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_license_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdLicenseGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_payment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdPaymentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_plan_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdPlanTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_public_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdPublicKeyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_reinstate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdReinstatePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_rotate_api_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdRotateApiKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_seat_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSeatPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_sm_subscription_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSmSubscriptionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_sso_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSsoGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_sso_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSsoPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_storage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdStoragePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_subscribe_secrets_manager_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSubscribeSecretsManagerPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_subscription_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSubscriptionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_subscription_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdSubscriptionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_tax_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdTaxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_tax_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdTaxPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_upgrade_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdUpgradePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_id_verify_bank_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdVerifyBankPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_identifier_auto_enroll_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsIdentifierAutoEnrollStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostError {
    UnknownValue(serde_json::Value),
}

pub async fn organizations_create_without_payment_post(
    configuration: &configuration::Configuration,
    organization_no_payment_create_request: Option<models::OrganizationNoPaymentCreateRequest>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsCreateWithoutPaymentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_no_payment_create_request = organization_no_payment_create_request;

    let uri_str = format!(
        "{}/organizations/create-without-payment",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_no_payment_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsCreateWithoutPaymentPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get(
    configuration: &configuration::Configuration,
) -> Result<models::ProfileOrganizationResponseModelListResponseModel, Error<OrganizationsGetError>>
{
    let uri_str = format!("{}/organizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_api_key_information_type_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    r#type: models::OrganizationApiKeyType,
) -> Result<
    models::OrganizationApiKeyInformationListResponseModel,
    Error<OrganizationsIdApiKeyInformationTypeGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_type = r#type;

    let uri_str = format!("{}/organizations/{id}/api-key-information/{type}", configuration.base_path, id=crate::apis::urlencode(p_id.to_string()), type=p_type.to_string());
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationApiKeyInformationListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationApiKeyInformationListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdApiKeyInformationTypeGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_api_key_post(
    configuration: &configuration::Configuration,
    id: &str,
    organization_api_key_request_model: Option<models::OrganizationApiKeyRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<OrganizationsIdApiKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_api_key_request_model = organization_api_key_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/api-key",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_api_key_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdApiKeyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_cancel_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    subscription_cancellation_request_model: Option<models::SubscriptionCancellationRequestModel>,
) -> Result<(), Error<OrganizationsIdCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_subscription_cancellation_request_model = subscription_cancellation_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/cancel",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_subscription_cancellation_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_collection_management_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_collection_management_update_request_model: Option<
        models::OrganizationCollectionManagementUpdateRequestModel,
    >,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsIdCollectionManagementPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_collection_management_update_request_model =
        organization_collection_management_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/collection-management",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_collection_management_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdCollectionManagementPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_delete(
    configuration: &configuration::Configuration,
    id: &str,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<OrganizationsIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_delete_post(
    configuration: &configuration::Configuration,
    id: &str,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<OrganizationsIdDeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/delete",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdDeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_delete_recover_token_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_verify_delete_recover_request_model: Option<
        models::OrganizationVerifyDeleteRecoverRequestModel,
    >,
) -> Result<(), Error<OrganizationsIdDeleteRecoverTokenPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_verify_delete_recover_request_model =
        organization_verify_delete_recover_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/delete-recover-token",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_verify_delete_recover_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdDeleteRecoverTokenPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_keys_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::OrganizationPublicKeyResponseModel, Error<OrganizationsIdKeysGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/keys",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdKeysGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_keys_post(
    configuration: &configuration::Configuration,
    id: &str,
    organization_keys_request_model: Option<models::OrganizationKeysRequestModel>,
) -> Result<models::OrganizationKeysResponseModel, Error<OrganizationsIdKeysPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_keys_request_model = organization_keys_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/keys",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_keys_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationKeysResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationKeysResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdKeysPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_leave_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsIdLeavePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/leave",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdLeavePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_license_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    installation_id: Option<uuid::Uuid>,
) -> Result<models::OrganizationLicense, Error<OrganizationsIdLicenseGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_installation_id = installation_id;

    let uri_str = format!(
        "{}/organizations/{id}/license",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_installation_id {
        req_builder = req_builder.query(&[("installationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationLicense`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationLicense`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdLicenseGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_payment_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    payment_request_model: Option<models::PaymentRequestModel>,
) -> Result<(), Error<OrganizationsIdPaymentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_payment_request_model = payment_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/payment",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_payment_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdPaymentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_plan_type_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::PlanType, Error<OrganizationsIdPlanTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/plan-type",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlanType`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlanType`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdPlanTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_post(
    configuration: &configuration::Configuration,
    id: &str,
    organization_update_request_model: Option<models::OrganizationUpdateRequestModel>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_update_request_model = organization_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_public_key_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::OrganizationPublicKeyResponseModel, Error<OrganizationsIdPublicKeyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/public-key",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdPublicKeyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_put(
    configuration: &configuration::Configuration,
    id: &str,
    organization_update_request_model: Option<models::OrganizationUpdateRequestModel>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_update_request_model = organization_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_reinstate_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsIdReinstatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/reinstate",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdReinstatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_rotate_api_key_post(
    configuration: &configuration::Configuration,
    id: &str,
    organization_api_key_request_model: Option<models::OrganizationApiKeyRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<OrganizationsIdRotateApiKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_api_key_request_model = organization_api_key_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/rotate-api-key",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_api_key_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdRotateApiKeyPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_seat_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_seat_request_model: Option<models::OrganizationSeatRequestModel>,
) -> Result<models::PaymentResponseModel, Error<OrganizationsIdSeatPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_seat_request_model = organization_seat_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/seat",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_seat_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSeatPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_sm_subscription_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    secrets_manager_subscription_update_request_model: Option<
        models::SecretsManagerSubscriptionUpdateRequestModel,
    >,
) -> Result<models::ProfileOrganizationResponseModel, Error<OrganizationsIdSmSubscriptionPostError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secrets_manager_subscription_update_request_model =
        secrets_manager_subscription_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/sm-subscription",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secrets_manager_subscription_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSmSubscriptionPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_sso_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::OrganizationSsoResponseModel, Error<OrganizationsIdSsoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/sso",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationSsoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationSsoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSsoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_sso_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_sso_request_model: Option<models::OrganizationSsoRequestModel>,
) -> Result<models::OrganizationSsoResponseModel, Error<OrganizationsIdSsoPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_sso_request_model = organization_sso_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/sso",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_sso_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationSsoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationSsoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSsoPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_storage_post(
    configuration: &configuration::Configuration,
    id: &str,
    storage_request_model: Option<models::StorageRequestModel>,
) -> Result<models::PaymentResponseModel, Error<OrganizationsIdStoragePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_storage_request_model = storage_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/storage",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_storage_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdStoragePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_subscribe_secrets_manager_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    secrets_manager_subscribe_request_model: Option<models::SecretsManagerSubscribeRequestModel>,
) -> Result<
    models::ProfileOrganizationResponseModel,
    Error<OrganizationsIdSubscribeSecretsManagerPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secrets_manager_subscribe_request_model = secrets_manager_subscribe_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/subscribe-secrets-manager",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secrets_manager_subscribe_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSubscribeSecretsManagerPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_subscription_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::OrganizationSubscriptionResponseModel, Error<OrganizationsIdSubscriptionGetError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/subscription",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationSubscriptionResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationSubscriptionResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSubscriptionGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_subscription_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_subscription_update_request_model: Option<
        models::OrganizationSubscriptionUpdateRequestModel,
    >,
) -> Result<models::ProfileOrganizationResponseModel, Error<OrganizationsIdSubscriptionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_subscription_update_request_model =
        organization_subscription_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/subscription",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_subscription_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdSubscriptionPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_tax_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::TaxInfoResponseModel, Error<OrganizationsIdTaxGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/tax",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaxInfoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaxInfoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdTaxGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_tax_put(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    expanded_tax_info_update_request_model: Option<models::ExpandedTaxInfoUpdateRequestModel>,
) -> Result<(), Error<OrganizationsIdTaxPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_expanded_tax_info_update_request_model = expanded_tax_info_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/tax",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_expanded_tax_info_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdTaxPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_upgrade_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_upgrade_request_model: Option<models::OrganizationUpgradeRequestModel>,
) -> Result<models::PaymentResponseModel, Error<OrganizationsIdUpgradePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_upgrade_request_model = organization_upgrade_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/upgrade",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_upgrade_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdUpgradePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_id_verify_bank_post(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_verify_bank_request_model: Option<models::OrganizationVerifyBankRequestModel>,
) -> Result<(), Error<OrganizationsIdVerifyBankPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_verify_bank_request_model = organization_verify_bank_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/verify-bank",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_verify_bank_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdVerifyBankPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_identifier_auto_enroll_status_get(
    configuration: &configuration::Configuration,
    identifier: &str,
) -> Result<
    models::OrganizationAutoEnrollStatusResponseModel,
    Error<OrganizationsIdentifierAutoEnrollStatusGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_identifier = identifier;

    let uri_str = format!(
        "{}/organizations/{identifier}/auto-enroll-status",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationAutoEnrollStatusResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationAutoEnrollStatusResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsIdentifierAutoEnrollStatusGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post(
    configuration: &configuration::Configuration,
    organization_create_request_model: Option<models::OrganizationCreateRequestModel>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_create_request_model = organization_create_request_model;

    let uri_str = format!("{}/organizations", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_create_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
