/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`organizations_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_api_key_information`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsApiKeyInformationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_create_without_payment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsCreateWithoutPaymentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_auto_enroll_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetAutoEnrollStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetKeysError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_license`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetLicenseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_plan_type`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetPlanTypeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_public_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetPublicKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_sso`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetSsoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_tax_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetTaxInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_get_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsGetUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_leave`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsLeaveError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_cancel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostCancelError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_delete_recover_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostDeleteRecoverTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostKeysError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_reinstate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostReinstateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_seat`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostSeatError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_sm_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostSmSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_sso`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostSsoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_storage`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostStorageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_subscribe_secrets_manager`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostSubscribeSecretsManagerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostSubscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_upgrade`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostUpgradeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_post_verify_bank`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPostVerifyBankError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_put_collection_management`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPutCollectionManagementError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_put_tax_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsPutTaxInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_rotate_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsRotateApiKeyError {
    UnknownValue(serde_json::Value),
}

pub async fn organizations_api_key(
    configuration: &configuration::Configuration,
    id: &str,
    organization_api_key_request_model: Option<models::OrganizationApiKeyRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<OrganizationsApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_api_key_request_model = organization_api_key_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/api-key",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_api_key_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_api_key_information(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    r#type: models::OrganizationApiKeyType,
) -> Result<
    models::OrganizationApiKeyInformationListResponseModel,
    Error<OrganizationsApiKeyInformationError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_type = r#type;

    let uri_str = format!("{}/organizations/{id}/api-key-information/{type}", configuration.base_path, id=crate::apis::urlencode(p_id.to_string()), type=p_type.to_string());
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationApiKeyInformationListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationApiKeyInformationListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsApiKeyInformationError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_create_without_payment(
    configuration: &configuration::Configuration,
    organization_no_payment_create_request: Option<models::OrganizationNoPaymentCreateRequest>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsCreateWithoutPaymentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_no_payment_create_request = organization_no_payment_create_request;

    let uri_str = format!(
        "{}/organizations/create-without-payment",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_no_payment_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsCreateWithoutPaymentError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_delete(
    configuration: &configuration::Configuration,
    id: &str,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<OrganizationsDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_auto_enroll_status(
    configuration: &configuration::Configuration,
    identifier: &str,
) -> Result<
    models::OrganizationAutoEnrollStatusResponseModel,
    Error<OrganizationsGetAutoEnrollStatusError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_identifier = identifier;

    let uri_str = format!(
        "{}/organizations/{identifier}/auto-enroll-status",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationAutoEnrollStatusResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationAutoEnrollStatusResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetAutoEnrollStatusError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_keys(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::OrganizationPublicKeyResponseModel, Error<OrganizationsGetKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/keys",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_license(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    installation_id: Option<uuid::Uuid>,
) -> Result<models::OrganizationLicense, Error<OrganizationsGetLicenseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_installation_id = installation_id;

    let uri_str = format!(
        "{}/organizations/{id}/license",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_installation_id {
        req_builder = req_builder.query(&[("installationId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationLicense`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationLicense`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetLicenseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_plan_type(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::PlanType, Error<OrganizationsGetPlanTypeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/plan-type",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlanType`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlanType`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetPlanTypeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_public_key(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::OrganizationPublicKeyResponseModel, Error<OrganizationsGetPublicKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/public-key",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationPublicKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetPublicKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_sso(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::OrganizationSsoResponseModel, Error<OrganizationsGetSsoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/sso",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationSsoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationSsoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetSsoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_subscription(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::OrganizationSubscriptionResponseModel, Error<OrganizationsGetSubscriptionError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/subscription",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationSubscriptionResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationSubscriptionResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetSubscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_tax_info(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<models::TaxInfoResponseModel, Error<OrganizationsGetTaxInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/tax",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaxInfoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaxInfoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetTaxInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_get_user(
    configuration: &configuration::Configuration,
) -> Result<
    models::ProfileOrganizationResponseModelListResponseModel,
    Error<OrganizationsGetUserError>,
> {
    let uri_str = format!("{}/organizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsGetUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_leave(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsLeaveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/leave",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsLeaveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

///  This operation is defined on: [`https://github.com/bitwarden/server/blob/22420f595f2f50dd2fc0061743841285258aed22/src/Api/AdminConsole/Controllers/OrganizationsController.cs#L198`]
pub async fn organizations_post(
    configuration: &configuration::Configuration,
    organization_create_request_model: Option<models::OrganizationCreateRequestModel>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_organization_create_request_model = organization_create_request_model;

    let uri_str = format!("{}/organizations", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_create_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_cancel(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    subscription_cancellation_request_model: Option<models::SubscriptionCancellationRequestModel>,
) -> Result<(), Error<OrganizationsPostCancelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_subscription_cancellation_request_model = subscription_cancellation_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/cancel",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_subscription_cancellation_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostCancelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_delete(
    configuration: &configuration::Configuration,
    id: &str,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<(), Error<OrganizationsPostDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/delete",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_delete_recover_token(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_verify_delete_recover_request_model: Option<
        models::OrganizationVerifyDeleteRecoverRequestModel,
    >,
) -> Result<(), Error<OrganizationsPostDeleteRecoverTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_verify_delete_recover_request_model =
        organization_verify_delete_recover_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/delete-recover-token",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_verify_delete_recover_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostDeleteRecoverTokenError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_keys(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_keys_request_model: Option<models::OrganizationKeysRequestModel>,
) -> Result<models::OrganizationKeysResponseModel, Error<OrganizationsPostKeysError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_keys_request_model = organization_keys_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/keys",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_keys_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationKeysResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationKeysResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_put(
    configuration: &configuration::Configuration,
    id: &str,
    organization_update_request_model: Option<models::OrganizationUpdateRequestModel>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsPostPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_update_request_model = organization_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_reinstate(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsPostReinstateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/reinstate",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostReinstateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_seat(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_seat_request_model: Option<models::OrganizationSeatRequestModel>,
) -> Result<models::PaymentResponseModel, Error<OrganizationsPostSeatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_seat_request_model = organization_seat_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/seat",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_seat_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostSeatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_sm_subscription(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    secrets_manager_subscription_update_request_model: Option<
        models::SecretsManagerSubscriptionUpdateRequestModel,
    >,
) -> Result<models::ProfileOrganizationResponseModel, Error<OrganizationsPostSmSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secrets_manager_subscription_update_request_model =
        secrets_manager_subscription_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/sm-subscription",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secrets_manager_subscription_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostSmSubscriptionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_sso(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_sso_request_model: Option<models::OrganizationSsoRequestModel>,
) -> Result<models::OrganizationSsoResponseModel, Error<OrganizationsPostSsoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_sso_request_model = organization_sso_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/sso",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_sso_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationSsoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationSsoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostSsoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_storage(
    configuration: &configuration::Configuration,
    id: &str,
    storage_request_model: Option<models::StorageRequestModel>,
) -> Result<models::PaymentResponseModel, Error<OrganizationsPostStorageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_storage_request_model = storage_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/storage",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_storage_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostStorageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_subscribe_secrets_manager(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    secrets_manager_subscribe_request_model: Option<models::SecretsManagerSubscribeRequestModel>,
) -> Result<
    models::ProfileOrganizationResponseModel,
    Error<OrganizationsPostSubscribeSecretsManagerError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secrets_manager_subscribe_request_model = secrets_manager_subscribe_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/subscribe-secrets-manager",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secrets_manager_subscribe_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostSubscribeSecretsManagerError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_subscription(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_subscription_update_request_model: Option<
        models::OrganizationSubscriptionUpdateRequestModel,
    >,
) -> Result<models::ProfileOrganizationResponseModel, Error<OrganizationsPostSubscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_subscription_update_request_model =
        organization_subscription_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/subscription",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_subscription_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProfileOrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostSubscriptionError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_upgrade(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_upgrade_request_model: Option<models::OrganizationUpgradeRequestModel>,
) -> Result<models::PaymentResponseModel, Error<OrganizationsPostUpgradeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_upgrade_request_model = organization_upgrade_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/upgrade",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_upgrade_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostUpgradeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_post_verify_bank(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_verify_bank_request_model: Option<models::OrganizationVerifyBankRequestModel>,
) -> Result<(), Error<OrganizationsPostVerifyBankError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_verify_bank_request_model = organization_verify_bank_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/verify-bank",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_verify_bank_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPostVerifyBankError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_put(
    configuration: &configuration::Configuration,
    id: &str,
    organization_update_request_model: Option<models::OrganizationUpdateRequestModel>,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_update_request_model = organization_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_put_collection_management(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    organization_collection_management_update_request_model: Option<
        models::OrganizationCollectionManagementUpdateRequestModel,
    >,
) -> Result<models::OrganizationResponseModel, Error<OrganizationsPutCollectionManagementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_collection_management_update_request_model =
        organization_collection_management_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/collection-management",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_collection_management_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPutCollectionManagementError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_put_tax_info(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    expanded_tax_info_update_request_model: Option<models::ExpandedTaxInfoUpdateRequestModel>,
) -> Result<(), Error<OrganizationsPutTaxInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_expanded_tax_info_update_request_model = expanded_tax_info_update_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/tax",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_expanded_tax_info_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsPutTaxInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_rotate_api_key(
    configuration: &configuration::Configuration,
    id: &str,
    organization_api_key_request_model: Option<models::OrganizationApiKeyRequestModel>,
) -> Result<models::ApiKeyResponseModel, Error<OrganizationsRotateApiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_organization_api_key_request_model = organization_api_key_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/rotate-api-key",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_api_key_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsRotateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
