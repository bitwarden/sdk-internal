/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`organizations_org_id_users_account_recovery_details_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersAccountRecoveryDetailsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersConfirmPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_delete_account_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersDeleteAccountDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_delete_account_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersDeleteAccountPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_enable_secrets_manager_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersEnableSecretsManagerPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_enable_secrets_manager_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersEnableSecretsManagerPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdConfirmPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_delete_account_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdDeleteAccountDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_delete_account_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdDeleteAccountPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdGroupsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_reinvite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdReinvitePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_remove_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdRemovePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_reset_password_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdResetPasswordDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_reset_password_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdResetPasswordPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_restore_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdRestorePatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_restore_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdRestorePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_revoke_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdRevokePatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_id_revoke_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersIdRevokePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_invite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersInvitePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_mini_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersMiniDetailsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`organizations_org_id_users_organization_user_id_accept_init_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersOrganizationUserIdAcceptInitPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`organizations_org_id_users_organization_user_id_accept_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersOrganizationUserIdAcceptPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_public_keys_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersPublicKeysPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_reinvite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersReinvitePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_remove_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersRemovePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_restore_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersRestorePatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_restore_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersRestorePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_revoke_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersRevokePatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`organizations_org_id_users_revoke_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersRevokePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method
/// [`organizations_org_id_users_user_id_reset_password_enrollment_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrganizationsOrgIdUsersUserIdResetPasswordEnrollmentPutError {
    UnknownValue(serde_json::Value),
}

pub async fn organizations_org_id_users_account_recovery_details_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserResetPasswordDetailsResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersAccountRecoveryDetailsPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/account-recovery-details",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserResetPasswordDetailsResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserResetPasswordDetailsResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersAccountRecoveryDetailsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_confirm_post(
    configuration: &configuration::Configuration,
    org_id: &str,
    organization_user_bulk_confirm_request_model: Option<
        models::OrganizationUserBulkConfirmRequestModel,
    >,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersConfirmPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_confirm_request_model =
        organization_user_bulk_confirm_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/confirm",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_confirm_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersConfirmPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_delete(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersDeleteError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_delete_account_delete(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersDeleteAccountDeleteError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/delete-account",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersDeleteAccountDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_delete_account_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersDeleteAccountPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/delete-account",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersDeleteAccountPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_enable_secrets_manager_patch(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersEnableSecretsManagerPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/enable-secrets-manager",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersEnableSecretsManagerPatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_enable_secrets_manager_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersEnableSecretsManagerPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/enable-secrets-manager",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersEnableSecretsManagerPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_get(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    include_groups: Option<bool>,
    include_collections: Option<bool>,
) -> Result<
    models::OrganizationUserUserDetailsResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_include_groups = include_groups;
    let p_include_collections = include_collections;

    let uri_str = format!(
        "{}/organizations/{orgId}/users",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_groups {
        req_builder = req_builder.query(&[("includeGroups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_collections {
        req_builder = req_builder.query(&[("includeCollections", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserUserDetailsResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserUserDetailsResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_confirm_post(
    configuration: &configuration::Configuration,
    org_id: &str,
    id: &str,
    organization_user_confirm_request_model: Option<models::OrganizationUserConfirmRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersIdConfirmPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;
    let p_organization_user_confirm_request_model = organization_user_confirm_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/confirm",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id),
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_confirm_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdConfirmPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_delete(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_delete_account_delete(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdDeleteAccountDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/delete-account",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdDeleteAccountDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_delete_account_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdDeleteAccountPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/delete-account",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdDeleteAccountPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_get(
    configuration: &configuration::Configuration,
    id: uuid::Uuid,
    org_id: &str,
    include_groups: Option<bool>,
) -> Result<models::OrganizationUserDetailsResponseModel, Error<OrganizationsOrgIdUsersIdGetError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_org_id = org_id;
    let p_include_groups = include_groups;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}",
        configuration.base_path,
        id = crate::apis::urlencode(p_id.to_string()),
        orgId = crate::apis::urlencode(p_org_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_groups {
        req_builder = req_builder.query(&[("includeGroups", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_groups_get(
    configuration: &configuration::Configuration,
    org_id: &str,
    id: &str,
) -> Result<Vec<String>, Error<OrganizationsOrgIdUsersIdGroupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/groups",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id),
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdGroupsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
    organization_user_update_request_model: Option<models::OrganizationUserUpdateRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;
    let p_organization_user_update_request_model = organization_user_update_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
    organization_user_update_request_model: Option<models::OrganizationUserUpdateRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;
    let p_organization_user_update_request_model = organization_user_update_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_update_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_reinvite_post(
    configuration: &configuration::Configuration,
    org_id: &str,
    id: &str,
) -> Result<(), Error<OrganizationsOrgIdUsersIdReinvitePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/reinvite",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id),
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdReinvitePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_remove_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdRemovePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/remove",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdRemovePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_reset_password_details_get(
    configuration: &configuration::Configuration,
    org_id: &str,
    id: &str,
) -> Result<
    models::OrganizationUserResetPasswordDetailsResponseModel,
    Error<OrganizationsOrgIdUsersIdResetPasswordDetailsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/reset-password-details",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id),
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserResetPasswordDetailsResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserResetPasswordDetailsResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdResetPasswordDetailsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_reset_password_put(
    configuration: &configuration::Configuration,
    org_id: &str,
    id: &str,
    organization_user_reset_password_request_model: Option<
        models::OrganizationUserResetPasswordRequestModel,
    >,
) -> Result<(), Error<OrganizationsOrgIdUsersIdResetPasswordPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;
    let p_organization_user_reset_password_request_model =
        organization_user_reset_password_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/reset-password",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id),
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_reset_password_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdResetPasswordPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_restore_patch(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdRestorePatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/restore",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdRestorePatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_restore_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdRestorePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/restore",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdRestorePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_revoke_patch(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdRevokePatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/revoke",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdRevokePatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_id_revoke_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    id: uuid::Uuid,
) -> Result<(), Error<OrganizationsOrgIdUsersIdRevokePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{id}/revoke",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        id = crate::apis::urlencode(p_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersIdRevokePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_invite_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_invite_request_model: Option<models::OrganizationUserInviteRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersInvitePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_invite_request_model = organization_user_invite_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/invite",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_invite_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersInvitePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_mini_details_get(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
) -> Result<
    models::OrganizationUserUserMiniDetailsResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersMiniDetailsGetError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/mini-details",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserUserMiniDetailsResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserUserMiniDetailsResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersMiniDetailsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_organization_user_id_accept_init_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_id: uuid::Uuid,
    organization_user_accept_init_request_model: Option<
        models::OrganizationUserAcceptInitRequestModel,
    >,
) -> Result<(), Error<OrganizationsOrgIdUsersOrganizationUserIdAcceptInitPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_id = organization_user_id;
    let p_organization_user_accept_init_request_model = organization_user_accept_init_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{organizationUserId}/accept-init",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        organizationUserId = crate::apis::urlencode(p_organization_user_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_accept_init_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersOrganizationUserIdAcceptInitPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_organization_user_id_accept_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_id: uuid::Uuid,
    organization_user_accept_request_model: Option<models::OrganizationUserAcceptRequestModel>,
) -> Result<(), Error<OrganizationsOrgIdUsersOrganizationUserIdAcceptPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_id = organization_user_id;
    let p_organization_user_accept_request_model = organization_user_accept_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{organizationUserId}/accept",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        organizationUserId = crate::apis::urlencode(p_organization_user_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_accept_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersOrganizationUserIdAcceptPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_public_keys_post(
    configuration: &configuration::Configuration,
    org_id: &str,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserPublicKeyResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersPublicKeysPostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/public-keys",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserPublicKeyResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserPublicKeyResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersPublicKeysPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_reinvite_post(
    configuration: &configuration::Configuration,
    org_id: &str,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersReinvitePostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/reinvite",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersReinvitePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_remove_post(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersRemovePostError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/remove",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersRemovePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_restore_patch(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersRestorePatchError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/restore",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersRestorePatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_restore_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersRestorePutError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/restore",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersRestorePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_revoke_patch(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersRevokePatchError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/revoke",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersRevokePatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_revoke_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    organization_user_bulk_request_model: Option<models::OrganizationUserBulkRequestModel>,
) -> Result<
    models::OrganizationUserBulkResponseModelListResponseModel,
    Error<OrganizationsOrgIdUsersRevokePutError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_organization_user_bulk_request_model = organization_user_bulk_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/revoke",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_bulk_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OrganizationUserBulkResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersRevokePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn organizations_org_id_users_user_id_reset_password_enrollment_put(
    configuration: &configuration::Configuration,
    org_id: uuid::Uuid,
    user_id: uuid::Uuid,
    organization_user_reset_password_enrollment_request_model: Option<
        models::OrganizationUserResetPasswordEnrollmentRequestModel,
    >,
) -> Result<(), Error<OrganizationsOrgIdUsersUserIdResetPasswordEnrollmentPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_org_id = org_id;
    let p_user_id = user_id;
    let p_organization_user_reset_password_enrollment_request_model =
        organization_user_reset_password_enrollment_request_model;

    let uri_str = format!(
        "{}/organizations/{orgId}/users/{userId}/reset-password-enrollment",
        configuration.base_path,
        orgId = crate::apis::urlencode(p_org_id.to_string()),
        userId = crate::apis::urlencode(p_user_id.to_string())
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_organization_user_reset_password_enrollment_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<OrganizationsOrgIdUsersUserIdResetPasswordEnrollmentPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
