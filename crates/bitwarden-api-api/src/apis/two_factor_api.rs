/*
 * Bitwarden Internal API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: latest
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};

/// struct for typed errors of method [`two_factor_delete_web_authn`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorDeleteWebAuthnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_disable_authenticator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorDisableAuthenticatorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_authenticator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetAuthenticatorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_device_verification_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetDeviceVerificationSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_duo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetDuoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_organization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetOrganizationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_organization_duo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetOrganizationDuoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_recover`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetRecoverError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_web_authn`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetWebAuthnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_get_yubi_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorGetYubiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_authenticator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostAuthenticatorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_disable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostDisableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_duo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostDuoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_organization_disable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostOrganizationDisableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_organization_duo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostOrganizationDuoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_web_authn`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostWebAuthnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_post_yubi_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPostYubiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_authenticator`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutAuthenticatorError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_device_verification_settings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutDeviceVerificationSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_disable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutDisableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_duo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutDuoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_organization_disable`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutOrganizationDisableError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_organization_duo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutOrganizationDuoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_web_authn`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutWebAuthnError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_put_yubi_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorPutYubiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_send_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorSendEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`two_factor_send_email_login`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TwoFactorSendEmailLoginError {
    UnknownValue(serde_json::Value),
}

pub async fn two_factor_delete_web_authn(
    configuration: &configuration::Configuration,
    two_factor_web_authn_delete_request_model: Option<models::TwoFactorWebAuthnDeleteRequestModel>,
) -> Result<models::TwoFactorWebAuthnResponseModel, Error<TwoFactorDeleteWebAuthnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_web_authn_delete_request_model = two_factor_web_authn_delete_request_model;

    let uri_str = format!("{}/two-factor/webauthn", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_web_authn_delete_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorDeleteWebAuthnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_disable_authenticator(
    configuration: &configuration::Configuration,
    two_factor_authenticator_disable_request_model: Option<
        models::TwoFactorAuthenticatorDisableRequestModel,
    >,
) -> Result<models::TwoFactorProviderResponseModel, Error<TwoFactorDisableAuthenticatorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_authenticator_disable_request_model =
        two_factor_authenticator_disable_request_model;

    let uri_str = format!("{}/two-factor/authenticator", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_authenticator_disable_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorDisableAuthenticatorError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get(
    configuration: &configuration::Configuration,
) -> Result<models::TwoFactorProviderResponseModelListResponseModel, Error<TwoFactorGetError>> {
    let uri_str = format!("{}/two-factor", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_authenticator(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorAuthenticatorResponseModel, Error<TwoFactorGetAuthenticatorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/two-factor/get-authenticator", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorAuthenticatorResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorAuthenticatorResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetAuthenticatorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_device_verification_settings(
    configuration: &configuration::Configuration,
) -> Result<
    models::DeviceVerificationResponseModel,
    Error<TwoFactorGetDeviceVerificationSettingsError>,
> {
    let uri_str = format!(
        "{}/two-factor/get-device-verification-settings",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeviceVerificationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeviceVerificationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetDeviceVerificationSettingsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_duo(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorDuoResponseModel, Error<TwoFactorGetDuoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/two-factor/get-duo", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetDuoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_email(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorEmailResponseModel, Error<TwoFactorGetEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/two-factor/get-email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorEmailResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorEmailResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_organization(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<
    models::TwoFactorProviderResponseModelListResponseModel,
    Error<TwoFactorGetOrganizationError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!(
        "{}/organizations/{id}/two-factor",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModelListResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModelListResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetOrganizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_organization_duo(
    configuration: &configuration::Configuration,
    id: &str,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorDuoResponseModel, Error<TwoFactorGetOrganizationDuoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/two-factor/get-duo",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetOrganizationDuoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_recover(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorRecoverResponseModel, Error<TwoFactorGetRecoverError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/two-factor/get-recover", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorRecoverResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorRecoverResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetRecoverError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_web_authn(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorWebAuthnResponseModel, Error<TwoFactorGetWebAuthnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/two-factor/get-webauthn", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetWebAuthnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_get_yubi_key(
    configuration: &configuration::Configuration,
    secret_verification_request_model: Option<models::SecretVerificationRequestModel>,
) -> Result<models::TwoFactorYubiKeyResponseModel, Error<TwoFactorGetYubiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_secret_verification_request_model = secret_verification_request_model;

    let uri_str = format!("{}/two-factor/get-yubikey", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_secret_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorYubiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorYubiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorGetYubiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_authenticator(
    configuration: &configuration::Configuration,
    update_two_factor_authenticator_request_model: Option<
        models::UpdateTwoFactorAuthenticatorRequestModel,
    >,
) -> Result<models::TwoFactorAuthenticatorResponseModel, Error<TwoFactorPostAuthenticatorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_authenticator_request_model =
        update_two_factor_authenticator_request_model;

    let uri_str = format!("{}/two-factor/authenticator", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_authenticator_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorAuthenticatorResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorAuthenticatorResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostAuthenticatorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_disable(
    configuration: &configuration::Configuration,
    two_factor_provider_request_model: Option<models::TwoFactorProviderRequestModel>,
) -> Result<models::TwoFactorProviderResponseModel, Error<TwoFactorPostDisableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_provider_request_model = two_factor_provider_request_model;

    let uri_str = format!("{}/two-factor/disable", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_provider_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostDisableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_duo(
    configuration: &configuration::Configuration,
    update_two_factor_duo_request_model: Option<models::UpdateTwoFactorDuoRequestModel>,
) -> Result<models::TwoFactorDuoResponseModel, Error<TwoFactorPostDuoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_duo_request_model = update_two_factor_duo_request_model;

    let uri_str = format!("{}/two-factor/duo", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_duo_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostDuoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_email(
    configuration: &configuration::Configuration,
    update_two_factor_email_request_model: Option<models::UpdateTwoFactorEmailRequestModel>,
) -> Result<models::TwoFactorEmailResponseModel, Error<TwoFactorPostEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_email_request_model = update_two_factor_email_request_model;

    let uri_str = format!("{}/two-factor/email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorEmailResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorEmailResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_organization_disable(
    configuration: &configuration::Configuration,
    id: &str,
    two_factor_provider_request_model: Option<models::TwoFactorProviderRequestModel>,
) -> Result<models::TwoFactorProviderResponseModel, Error<TwoFactorPostOrganizationDisableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_two_factor_provider_request_model = two_factor_provider_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/two-factor/disable",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_provider_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostOrganizationDisableError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_organization_duo(
    configuration: &configuration::Configuration,
    id: &str,
    update_two_factor_duo_request_model: Option<models::UpdateTwoFactorDuoRequestModel>,
) -> Result<models::TwoFactorDuoResponseModel, Error<TwoFactorPostOrganizationDuoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_update_two_factor_duo_request_model = update_two_factor_duo_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/two-factor/duo",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_duo_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostOrganizationDuoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_web_authn(
    configuration: &configuration::Configuration,
    two_factor_web_authn_request_model: Option<models::TwoFactorWebAuthnRequestModel>,
) -> Result<models::TwoFactorWebAuthnResponseModel, Error<TwoFactorPostWebAuthnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_web_authn_request_model = two_factor_web_authn_request_model;

    let uri_str = format!("{}/two-factor/webauthn", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_web_authn_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostWebAuthnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_post_yubi_key(
    configuration: &configuration::Configuration,
    update_two_factor_yubico_otp_request_model: Option<
        models::UpdateTwoFactorYubicoOtpRequestModel,
    >,
) -> Result<models::TwoFactorYubiKeyResponseModel, Error<TwoFactorPostYubiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_yubico_otp_request_model = update_two_factor_yubico_otp_request_model;

    let uri_str = format!("{}/two-factor/yubikey", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_yubico_otp_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorYubiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorYubiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPostYubiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_authenticator(
    configuration: &configuration::Configuration,
    update_two_factor_authenticator_request_model: Option<
        models::UpdateTwoFactorAuthenticatorRequestModel,
    >,
) -> Result<models::TwoFactorAuthenticatorResponseModel, Error<TwoFactorPutAuthenticatorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_authenticator_request_model =
        update_two_factor_authenticator_request_model;

    let uri_str = format!("{}/two-factor/authenticator", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_authenticator_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorAuthenticatorResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorAuthenticatorResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutAuthenticatorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_device_verification_settings(
    configuration: &configuration::Configuration,
    device_verification_request_model: Option<models::DeviceVerificationRequestModel>,
) -> Result<
    models::DeviceVerificationResponseModel,
    Error<TwoFactorPutDeviceVerificationSettingsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_device_verification_request_model = device_verification_request_model;

    let uri_str = format!(
        "{}/two-factor/device-verification-settings",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_device_verification_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeviceVerificationResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeviceVerificationResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutDeviceVerificationSettingsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_disable(
    configuration: &configuration::Configuration,
    two_factor_provider_request_model: Option<models::TwoFactorProviderRequestModel>,
) -> Result<models::TwoFactorProviderResponseModel, Error<TwoFactorPutDisableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_provider_request_model = two_factor_provider_request_model;

    let uri_str = format!("{}/two-factor/disable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_provider_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutDisableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_duo(
    configuration: &configuration::Configuration,
    update_two_factor_duo_request_model: Option<models::UpdateTwoFactorDuoRequestModel>,
) -> Result<models::TwoFactorDuoResponseModel, Error<TwoFactorPutDuoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_duo_request_model = update_two_factor_duo_request_model;

    let uri_str = format!("{}/two-factor/duo", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_duo_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutDuoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_email(
    configuration: &configuration::Configuration,
    update_two_factor_email_request_model: Option<models::UpdateTwoFactorEmailRequestModel>,
) -> Result<models::TwoFactorEmailResponseModel, Error<TwoFactorPutEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_email_request_model = update_two_factor_email_request_model;

    let uri_str = format!("{}/two-factor/email", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorEmailResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorEmailResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_organization_disable(
    configuration: &configuration::Configuration,
    id: &str,
    two_factor_provider_request_model: Option<models::TwoFactorProviderRequestModel>,
) -> Result<models::TwoFactorProviderResponseModel, Error<TwoFactorPutOrganizationDisableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_two_factor_provider_request_model = two_factor_provider_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/two-factor/disable",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_provider_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorProviderResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutOrganizationDisableError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_organization_duo(
    configuration: &configuration::Configuration,
    id: &str,
    update_two_factor_duo_request_model: Option<models::UpdateTwoFactorDuoRequestModel>,
) -> Result<models::TwoFactorDuoResponseModel, Error<TwoFactorPutOrganizationDuoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_update_two_factor_duo_request_model = update_two_factor_duo_request_model;

    let uri_str = format!(
        "{}/organizations/{id}/two-factor/duo",
        configuration.base_path,
        id = crate::apis::urlencode(p_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_duo_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorDuoResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutOrganizationDuoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_web_authn(
    configuration: &configuration::Configuration,
    two_factor_web_authn_request_model: Option<models::TwoFactorWebAuthnRequestModel>,
) -> Result<models::TwoFactorWebAuthnResponseModel, Error<TwoFactorPutWebAuthnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_web_authn_request_model = two_factor_web_authn_request_model;

    let uri_str = format!("{}/two-factor/webauthn", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_web_authn_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorWebAuthnResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutWebAuthnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_put_yubi_key(
    configuration: &configuration::Configuration,
    update_two_factor_yubico_otp_request_model: Option<
        models::UpdateTwoFactorYubicoOtpRequestModel,
    >,
) -> Result<models::TwoFactorYubiKeyResponseModel, Error<TwoFactorPutYubiKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_two_factor_yubico_otp_request_model = update_two_factor_yubico_otp_request_model;

    let uri_str = format!("{}/two-factor/yubikey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_two_factor_yubico_otp_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TwoFactorYubiKeyResponseModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TwoFactorYubiKeyResponseModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorPutYubiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_send_email(
    configuration: &configuration::Configuration,
    two_factor_email_request_model: Option<models::TwoFactorEmailRequestModel>,
) -> Result<(), Error<TwoFactorSendEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_email_request_model = two_factor_email_request_model;

    let uri_str = format!("{}/two-factor/send-email", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorSendEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

pub async fn two_factor_send_email_login(
    configuration: &configuration::Configuration,
    two_factor_email_request_model: Option<models::TwoFactorEmailRequestModel>,
) -> Result<(), Error<TwoFactorSendEmailLoginError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_two_factor_email_request_model = two_factor_email_request_model;

    let uri_str = format!("{}/two-factor/send-email-login", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_two_factor_email_request_model);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TwoFactorSendEmailLoginError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
