{{>partial_header}}
use crate::models;
use serde::{Deserialize, Serialize};
{{#models}}
{{#model}}
{{^isEnum}}{{#vendorExtensions.x-rust-has-byte-array}}
use serde_with::serde_as;
{{/vendorExtensions.x-rust-has-byte-array}}{{/isEnum}}
{{#isEnum}}
{{#isInteger}}
use serde::{de::Visitor, Serializer, Deserializer};
{{/isInteger}}
{{/isEnum}}
{{#description}}
/// {{{classname}}} : {{{description}}}
{{/description}}
{{!-- for repr(int) enum schemas --}}
{{#isEnum}}
{{#isInteger}}
/// {{{description}}}
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub enum {{{classname}}} {
{{#allowableValues}}
{{#enumVars}}
    {{{name}}},
{{/enumVars}}{{/allowableValues}}
    /// Unknown value returned from the server. This is used to handle forward compatibility.
    __Unknown(i64),
}

impl {{{classname}}} {
    pub fn as_i64(&self) -> i64 {
        match self {
            {{#allowableValues}}
            {{#enumVars}}
            Self::{{{name}}} => {{{value}}},
            {{/enumVars}}
            {{/allowableValues}}
            Self::__Unknown(v) => *v,
        }
    }

    pub fn from_i64(value: i64) -> Self {
        match value {
            {{#allowableValues}}
            {{#enumVars}}
            {{{value}}} => Self::{{{name}}},
            {{/enumVars}}
            {{/allowableValues}}
            v => Self::__Unknown(v),
        }
    }
}

impl serde::Serialize for {{{classname}}} {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        serializer.serialize_i64(self.as_i64())
    }
}

impl<'de> serde::Deserialize<'de> for {{{classname}}} {
    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        struct {{{classname}}}Visitor;

        impl Visitor<'_> for {{{classname}}}Visitor {
            type Value = {{{classname}}};

            fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.write_str("an integer")
            }

            fn visit_i64<E: serde::de::Error>(self, v: i64) -> Result<Self::Value, E> {
                Ok({{{classname}}}::from_i64(v))
            }

            fn visit_u64<E: serde::de::Error>(self, v: u64) -> Result<Self::Value, E> {
                Ok({{{classname}}}::from_i64(v as i64))
            }
        }

        deserializer.deserialize_i64({{{classname}}}Visitor)
    }
}

impl std::fmt::Display for {{{classname}}} {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_i64())
    }
}
{{/isInteger}}
{{/isEnum}}
{{!-- for enum schemas --}}
{{#isEnum}}
{{^isInteger}}
/// {{{description}}}
#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum {{{classname}}} {
{{#allowableValues}}
{{#enumVars}}
    #[serde(rename = "{{{value}}}")]
    {{{name}}},
{{/enumVars}}{{/allowableValues}}
    /// Unknown value returned from the server. This is used to handle forward compatibility.
    #[serde(untagged)]
    __Unknown(String),
}

impl std::fmt::Display for {{{classname}}} {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            {{#allowableValues}}
            {{#enumVars}}
            Self::{{{name}}} => write!(f, "{{{value}}}"),
            {{/enumVars}}
            {{/allowableValues}}
            Self::__Unknown(s) => write!(f, "{}", s),
        }
    }
}

{{/isInteger}}
impl Default for {{{classname}}} {
    fn default() -> {{{classname}}} {
        {{#allowableValues}}
        Self::{{ enumVars.0.name }}
        {{/allowableValues}}
    }
}
{{/isEnum}}
{{!-- for schemas that have a discriminator --}}
{{#discriminator}}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(tag = "{{{propertyBaseName}}}")]
pub enum {{{classname}}} {
    {{^oneOf}}
    {{#mappedModels}}
    #[serde(rename="{{mappingName}}")]
    {{{modelName}}} {
    {{#vars}}
        {{#description}}
        /// {{{.}}}
        {{/description}}
        #[serde(rename = "{{{baseName}}}", alias = "{{{nameInPascalCase}}}"{{^required}}, skip_serializing_if = "Option::is_none"{{/required}})]
        {{{name}}}: {{#required}}{{#isNullable}}Option<{{/isNullable}}{{/required}}{{^required}}Option<{{/required}}{{#isEnum}}{{{enumName}}}{{/isEnum}}{{^isEnum}}{{#isModel}}{{^avoidBoxedModels}}Box<{{/avoidBoxedModels}}{{{dataType}}}{{^avoidBoxedModels}}>{{/avoidBoxedModels}}{{/isModel}}{{^isModel}}{{{dataType}}}{{/isModel}}{{/isEnum}}{{#required}}{{#isNullable}}>{{/isNullable}}{{/required}}{{^required}}>{{/required}},
    {{/vars}}
    },
    {{/mappedModels}}
    {{/oneOf}}
    {{^oneOf.isEmpty}}
    {{#composedSchemas.oneOf}}
    {{#description}}
    /// {{{.}}}
    {{/description}}
    {{#baseName}}
    #[serde(rename="{{{.}}}")]
    {{/baseName}}
    {{{name}}}({{#isModel}}{{^avoidBoxedModels}}Box<{{/avoidBoxedModels}}{{/isModel}}{{{dataType}}}{{#isModel}}{{^avoidBoxedModels}}>{{/avoidBoxedModels}}{{/isModel}}),
    {{/composedSchemas.oneOf}}
    {{/oneOf.isEmpty}}
}

impl Default for {{classname}} {
    fn default() -> Self {
        {{^oneOf}}{{#mappedModels}}{{#-first}}Self::{{modelName}} {
        {{#vars}}
            {{{name}}}: Default::default(),
        {{/vars}}
        }{{/-first}}{{/mappedModels}}
        {{/oneOf}}{{^oneOf.isEmpty}}{{#composedSchemas.oneOf}}{{#-first}}Self::{{{name}}}(Default::default()){{/-first}}{{/composedSchemas.oneOf}}{{/oneOf.isEmpty}}
    }
}

{{/discriminator}}
{{!-- for non-enum schemas --}}
{{^isEnum}}
{{^discriminator}}
{{#composedSchemas}}
{{#oneOf}}
{{#-first}}
{{! Model with composedSchemas.oneOf - generate enum}}
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{classname}} {
{{/-first}}
{{/oneOf}}
{{/composedSchemas}}
{{#composedSchemas}}
{{#oneOf}}
    {{#description}}
    /// {{{.}}}
    {{/description}}
    {{{name}}}({{#isModel}}{{^avoidBoxedModels}}Box<{{/avoidBoxedModels}}{{/isModel}}{{{dataType}}}{{#isModel}}{{^avoidBoxedModels}}>{{/avoidBoxedModels}}{{/isModel}}),
{{/oneOf}}
{{/composedSchemas}}
{{#composedSchemas}}
{{#oneOf}}
{{#-last}}
}

impl Default for {{classname}} {
    fn default() -> Self {
        {{#oneOf}}{{#-first}}Self::{{{name}}}(Default::default()){{/-first}}{{/oneOf}}
    }
}
{{/-last}}
{{/oneOf}}
{{^oneOf}}
{{! composedSchemas exists but no oneOf - generate normal struct}}
{{#vendorExtensions.x-rust-has-byte-array}}#[serde_as]
{{/vendorExtensions.x-rust-has-byte-array}}#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct {{{classname}}} {
{{#vars}}
    {{#description}}
    /// {{{.}}}
    {{/description}}
    {{#isByteArray}}
    {{#vendorExtensions.isMandatory}}#[serde_as(as = "serde_with::base64::Base64")]{{/vendorExtensions.isMandatory}}{{^vendorExtensions.isMandatory}}#[serde_as(as = "Option<serde_with::base64::Base64>")]{{/vendorExtensions.isMandatory}}
    {{/isByteArray}}
    #[serde(rename = "{{{baseName}}}", alias = "{{{nameInPascalCase}}}"{{^required}}, skip_serializing_if = "Option::is_none"{{/required}})]
    pub {{{name}}}: {{!
    ### Option Start
    }}{{#isNullable}}Option<{{/isNullable}}{{^required}}{{^isNullable}}Option<{{/isNullable}}{{/required}}{{!
    ### Enums
    }}{{#isEnum}}{{#isArray}}{{#uniqueItems}}std::collections::HashSet<{{/uniqueItems}}{{^uniqueItems}}Vec<{{/uniqueItems}}{{/isArray}}{{{enumName}}}{{#isArray}}>{{/isArray}}{{/isEnum}}{{!
    ### Non-Enums Start
    }}{{^isEnum}}{{!
    ### Models
    }}{{#isModel}}{{^avoidBoxedModels}}Box<{{/avoidBoxedModels}}{{{dataType}}}{{^avoidBoxedModels}}>{{/avoidBoxedModels}}{{/isModel}}{{!
    ### Primative datatypes
    }}{{^isModel}}{{#isByteArray}}Vec<u8>{{/isByteArray}}{{^isByteArray}}{{{dataType}}}{{/isByteArray}}{{/isModel}}{{!
    ### Non-Enums End
    }}{{/isEnum}}{{!
    ### Option End (and trailing comma)
    }}{{#isNullable}}>{{/isNullable}}{{^required}}{{^isNullable}}>{{/isNullable}}{{/required}},
{{/vars}}
}

impl {{{classname}}} {
    {{#description}}
    /// {{{.}}}
    {{/description}}
    pub fn new({{#requiredVars}}{{{name}}}: {{!
    ### Option Start
    }}{{#isNullable}}Option<{{/isNullable}}{{!
    ### Enums
    }}{{#isEnum}}{{#isArray}}{{#uniqueItems}}std::collections::HashSet<{{/uniqueItems}}{{^uniqueItems}}Vec<{{/uniqueItems}}{{/isArray}}{{{enumName}}}{{#isArray}}>{{/isArray}}{{/isEnum}}{{!
    ### Non-Enums
    }}{{^isEnum}}{{#isByteArray}}Vec<u8>{{/isByteArray}}{{^isByteArray}}{{{dataType}}}{{/isByteArray}}{{/isEnum}}{{!
    ### Option End
    }}{{#isNullable}}>{{/isNullable}}{{!
    ### Comma for next arguement
    }}{{^-last}}, {{/-last}}{{/requiredVars}}) -> {{{classname}}} {
        {{{classname}}} {
            {{#vars}}
            {{{name}}}{{^required}}: None{{/required}}{{#required}}{{#isModel}}{{^avoidBoxedModels}}: {{^isNullable}}Box::new({{{name}}}){{/isNullable}}{{#isNullable}}if let Some(x) = {{{name}}} {Some(Box::new(x))} else {None}{{/isNullable}}{{/avoidBoxedModels}}{{/isModel}}{{/required}},
            {{/vars}}
        }
    }
}
{{/oneOf}}
{{/composedSchemas}}
{{^composedSchemas}}
{{! Normal struct without composedSchemas}}
{{#vendorExtensions.x-rust-has-byte-array}}#[serde_as]
{{/vendorExtensions.x-rust-has-byte-array}}#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct {{{classname}}} {
{{#vars}}
    {{#description}}
    /// {{{.}}}
    {{/description}}
    {{#isByteArray}}
    {{#vendorExtensions.isMandatory}}#[serde_as(as = "serde_with::base64::Base64")]{{/vendorExtensions.isMandatory}}{{^vendorExtensions.isMandatory}}#[serde_as(as = "Option<serde_with::base64::Base64>")]{{/vendorExtensions.isMandatory}}
    {{/isByteArray}}
    #[serde(rename = "{{{baseName}}}", alias = "{{{nameInPascalCase}}}"{{^required}}, skip_serializing_if = "Option::is_none"{{/required}})]
    pub {{{name}}}: {{!
    ### Option Start
    }}{{#isNullable}}Option<{{/isNullable}}{{^required}}{{^isNullable}}Option<{{/isNullable}}{{/required}}{{!
    ### Enums
    }}{{#isEnum}}{{#isArray}}{{#uniqueItems}}std::collections::HashSet<{{/uniqueItems}}{{^uniqueItems}}Vec<{{/uniqueItems}}{{/isArray}}{{{enumName}}}{{#isArray}}>{{/isArray}}{{/isEnum}}{{!
    ### Non-Enums Start
    }}{{^isEnum}}{{!
    ### Models
    }}{{#isModel}}{{^avoidBoxedModels}}Box<{{/avoidBoxedModels}}{{{dataType}}}{{^avoidBoxedModels}}>{{/avoidBoxedModels}}{{/isModel}}{{!
    ### Primative datatypes
    }}{{^isModel}}{{#isByteArray}}Vec<u8>{{/isByteArray}}{{^isByteArray}}{{{dataType}}}{{/isByteArray}}{{/isModel}}{{!
    ### Non-Enums End
    }}{{/isEnum}}{{!
    ### Option End (and trailing comma)
    }}{{#isNullable}}>{{/isNullable}}{{^required}}{{^isNullable}}>{{/isNullable}}{{/required}},
{{/vars}}
}

impl {{{classname}}} {
    {{#description}}
    /// {{{.}}}
    {{/description}}
    pub fn new({{#requiredVars}}{{{name}}}: {{!
    ### Option Start
    }}{{#isNullable}}Option<{{/isNullable}}{{!
    ### Enums
    }}{{#isEnum}}{{#isArray}}{{#uniqueItems}}std::collections::HashSet<{{/uniqueItems}}{{^uniqueItems}}Vec<{{/uniqueItems}}{{/isArray}}{{{enumName}}}{{#isArray}}>{{/isArray}}{{/isEnum}}{{!
    ### Non-Enums
    }}{{^isEnum}}{{#isByteArray}}Vec<u8>{{/isByteArray}}{{^isByteArray}}{{{dataType}}}{{/isByteArray}}{{/isEnum}}{{!
    ### Option End
    }}{{#isNullable}}>{{/isNullable}}{{!
    ### Comma for next arguement
    }}{{^-last}}, {{/-last}}{{/requiredVars}}) -> {{{classname}}} {
        {{{classname}}} {
            {{#vars}}
            {{{name}}}{{^required}}: None{{/required}}{{#required}}{{#isModel}}{{^avoidBoxedModels}}: {{^isNullable}}Box::new({{{name}}}){{/isNullable}}{{#isNullable}}if let Some(x) = {{{name}}} {Some(Box::new(x))} else {None}{{/isNullable}}{{/avoidBoxedModels}}{{/isModel}}{{/required}},
            {{/vars}}
        }
    }
}
{{/composedSchemas}}
{{/discriminator}}
{{/isEnum}}
{{!-- for properties that are of enum type --}}
{{#vars}}
{{#isEnum}}
/// {{{description}}}
#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum {{{enumName}}} {
{{#allowableValues}}
{{#enumVars}}
    #[serde(rename = "{{{value}}}")]
    {{{name}}},
{{/enumVars}}
{{/allowableValues}}
    /// Unknown value returned from the server. This is used to handle forward compatibility.
    #[serde(untagged)]
    __Unknown(String),
}

impl Default for {{{enumName}}} {
    fn default() -> {{{enumName}}} {
        {{#allowableValues}}
        Self::{{ enumVars.0.name }}
        {{/allowableValues}}
    }
}
{{/isEnum}}
{{/vars}}

{{/model}}
{{/models}}
